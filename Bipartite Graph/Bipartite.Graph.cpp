#include "stdafx.h"
#include "class.h"

bool Graph::CellReading() //метод класса дл€ считывани€ данных из файла и создани€ смежных св€зей между соседними узлами
{
	string s1, s2; //буфер-строки дл€ считывани€ имЄн узлов из файла
	ifstream in("C:\\graph.txt");
	uint i = 0; //вспомогательный челочисленный счЄтчик
	uint nodeindex = 0; //номер текущего индекса в массиве allnodes графа (а также счЄтчик количества узлов)
	uint help; //вспомогательна€ переменна€
	/*Ќј„јЋќ: вы€сн€ем количество строк/€чеек*/
	while (!in.eof()) //пока не достигнут конец файла
	{
		i++; //наращиваем количество строк
		getline(in, s1); //считываем следующую строку из файла
	}
	in.close(); //закрываем файл
	/* ќЌ≈÷: вы€сн€ем количество строк=€чеек*/
	in.open("C:\\graph.txt"); //открываем заново, чтобы сместить указатель в начало файла
	cout << " оличество €чеек в объ€вленной сетке: " << i << "\n";
	this->cc = i; //запоминаем количество €чеек
	this->cn = 4 * i; //временно устанавливаем максимальное количество узлов
	this->cells = new Cell[i]; //создаЄм массив €чеек в текущем объекте
	Node *tempnodes; //временный массив узлов
	tempnodes = new Node[this->cn]; //устанавливаем максимальный размер
	uint j = 0; // счЄтчик дл€ нынешней €чейки
	while (!in.eof())
	{
		getline(in, s1); // —читываем строчку в переменную s1
		uint k = 0; // счЄтчик узлов внутри €чейки
		s2 = "";
		for (i = 0; s1[i] != *""; i++) //пока не будет достигнут конец строки
		{
			if (i > sizeof(s1)) //если номер текущего символа стал больше, чем размер unsigned int
			{
				cout << "ќЎ»Ѕ ј: слишком длинное название €чейки.\n”величьте размер буфера";
				in.close(); //«акрываем файл
				return false; //выход из подпрограммы
			}
			if (s1[i] != *" ") //если текущий символ - не пробел
			{
				s2 = s2 + s1[i]; //то дополн€ем им s2
			}
			else
			{
				help = 0; //на каждом шаге обнул€ем вспомогательную переменную, иначе всЄ сломаетс€
				for (uint l = 0; l < this->cn; l++) //дл€ всех узлов
					if (tempnodes[l].name == s2) //ищем узел с таким же именем
					{
						help = l; //если нашли, то запоминаем его индекс
						break;
					};
				if (help != 0) this->cells[j].nodes[k] = help; //и записываем его в качестве индекса дл€ текущего узла
				else //а если не нашли
				{
					tempnodes[nodeindex].name = s2; //то создаЄм новый узел во временном массиве с текущим именем
					this->cells[j].nodes[k] = nodeindex; //и записываем его индекс
					nodeindex++; //увеличива€ при этом количество неповтор€ющихс€ узлов на 1
				}
				k++; //ещЄ один узел в €чейке сохранЄн
				s2 = ""; //обнул€ем строку
			}
		}
		/*Ќј„јЋќ: “ак как мы дошли до конца строки, котора€ не выдел€етс€ разделителем-пробелом,
		то 4-ому узлу присваиваем им€ вне цикла*/
		//этот момент аналогичен таким же на предыдущих шагах
		help = 0;
		for (uint l = 0; l < this->cn; l++)
			if (tempnodes[l].name == s2)
			{
				help = l;
				break;
			};
		if (help != 0) this->cells[j].nodes[k] = help;
		else
		{
			tempnodes[nodeindex].name = s2;
			this->cells[j].nodes[k] = nodeindex;
			nodeindex++;
		}
		j++;
		/* ќЌ≈÷: “ак как мы дошли до конца строки, котора€ не выдел€етс€ разделителем-пробелом,
		то 4-ому узлу присваиваем им€ вне цикла*/
	}
	in.close(); //«акрываем файл
	this->allnodes = new Node[nodeindex]; //создаЄм общий массив узлов в объекте по узнанному количеству узлов
	for (i = 0; i < nodeindex; i++) //дл€ всех узлов
		this->allnodes[i].name = tempnodes[i].name; //копируем их имена в основной массив объекта
	delete[] tempnodes; //удал€ем временный массив
	this->cn = nodeindex; //корректируем количество узлов
	cout << " оличество узлов в объ€вленной сетке: " << nodeindex << "\n"; //сообщаем великую новость

	/*Ќј„јЋќ: ѕроверка правильности занесени€ данных из файла в классовую структуру (оставить дл€ дебагинга)*/
	char ch;
	cout << "\n¬ќѕ–ќ—: ¬ывести на экран содержимое €чеек? (Y/N) "; //возникнет ошибка, если ввести символ на кириллице
	do {
		ch = _getch();
		if (islower(ch)) ch = toupper(ch);
	} while ((ch != 'Y') && (ch != 'N'));
	cout << ch << "\n\n";
	if (ch == 'Y')
	{
		for (j = 0; j < this->cc; j++)
		{
			cout << "ячейка є" << j + 1 << ": ";
			for (int k = 0; k <= 3; k++) cout << this->allnodes[this->cells[j].nodes[k]].name << " ";
			cout << "\n";
		}
		cout << "\n";
	}
	/* ќЌ≈÷: ѕроверка правильности занесени€ данных из файла в классовую структуру (оставить дл€ дебагинга)*/

	/*«јѕќЋЌ≈Ќ»≈ ƒјЌЌџћ» ќ —ћ≈∆Ќџ’ ”«Ћј’*/
	for (i = 0; i < this->cc; i++) //обходим все €чейки
	{
		uint index; //вспомогательна€ переменна€
		Cell c; //вспомогательный объ€ект-€чейка
		for (uint k = 0; k < 4; k++) //обходим все 4 узла €чейки
			/*соседи определ€ютс€ взависимости от положени€ узла (первый - нижний левый, направление - против часовой стрелки)*/
			switch (k)
			{
				case 0: //если первый узел
					c = this->cells[i]; //сокращаем название
					index = c.nodes[k]; //вытаскиваем индекс узла дл€ массива allnodes в графе
					this->allnodes[c.nodes[3]].neighbors.insert(index); //добавл€ем первый узел в множство соседей
					this->allnodes[c.nodes[1]].neighbors.insert(index); //второго и последнего пор€дкового узлов
					break;
				case 1: //если второй узел
					c = this->cells[i];
					index = c.nodes[k];
					this->allnodes[c.nodes[0]].neighbors.insert(index);
					this->allnodes[c.nodes[2]].neighbors.insert(index); //первого и третьего
					break;
				case 2: //если третий узел
					c = this->cells[i];
					index = c.nodes[k];
					this->allnodes[c.nodes[1]].neighbors.insert(index);
					this->allnodes[c.nodes[3]].neighbors.insert(index); //второго и последнего
					break;
				case 3: //если последний узел
					c = this->cells[i];
					index = c.nodes[k];
					this->allnodes[c.nodes[2]].neighbors.insert(index);
					this->allnodes[c.nodes[0]].neighbors.insert(index); //третьего и первого
					break;
			}
	}
	cout << "”—ѕ≈’: ‘айл считан корректно!\n"; //вывод на экран
	return true; //успешно завершаем программу
}

bool Graph::CheckAndMark(uint index, int c) //рекурентна€ функци€ обхода в глубину
{
	this->allnodes[index].flag = c; //присваиваем переданный флаг узлу с переданным индексом
	for (uint i = 0; i < this->cn; i++) //перебираем все индексы узлов
		if (this->allnodes[index].neighbors.count(i)) //если встречаем его в множестве "соседей" узла переданного индекса
			switch (this->allnodes[i].flag) //то смотрим на флаг "соседа"
			{
				case 0: //если не установлен
					if (c == 1) //то в зависимости от переданного флага
					{
						if (!this->CheckAndMark(i, 2)) //рекурентно вызываем этот же метод, где
						{							  //где ему будет присвоен передаваемый флаг (отличный от нынешнего)
							return false;			 //а также просмотрены все его "соседи"
						}
					}
					else
					{
						if (!this->CheckAndMark(i, 1))
						{
							return false;
						}
					}
					break;
				case 1: //если в узле уже установлен флаг, то провер€ем
					if (c == 1) return false; //его на равенство нынешнему - если равен, то граф недвудольный
					break;
				case 2:
					if (c == 2) return false;
					break;
			}
	return true; //если дошло до сюда, то значит с этим узлом всЄ ок
}

bool Graph::IsItBipartite() //метод, возвращающий ответ на вопрос
{
	bool b = this->CheckAndMark(this->cells[0].nodes[0], 1); //запоминаем ответ на вопрос (передаЄм в метод самый первый узели говорим, что нужно метить его в первую долю)
	if (b) cout << "ќ“¬≈“: √–ј‘ я¬Ћя≈“—я ƒ¬”ƒќЋ№Ќџћ\n\n";
	else cout << "ќ“¬≈“: √–ј‘ Ќ≈ я¬Ћя≈“—я ƒ¬”ƒќЋ№Ќџћ\n\n";
	return b; //возвращаем логический ответ
}

void Graph::SaveOutputFile() //метод сохранение выходного файла
{
	string savepath = "C:\\output.txt"; //указываем путь дл€ сохранени€
	ofstream out(savepath); // ќткрываем файл дл€ записи
	string part1,part2; // вспомогающие строки первой и второй долей
	uint index; //вспомогательна€ переменна€
	for (int i = 0; i < this->cc; i++) //дл€ все €чеек
	{
		part1 = part2 = ""; //обнул€ем строки
		for (int j = 0; j < 4; j++) //и всех узлов в каждой из €чейки
		{
			index = this->cells[i].nodes[j]; //считываем индекс узла в общем массиве
			switch (this->allnodes[index].flag) //смотрим на его флаг
			{
				case 1: //если "покрашен" в первую долю
					if (part1 == "") part1 = this->allnodes[index].name; //то заносим им€ узла в строку без пробела
					else part1 = part1 + " " + this->allnodes[index].name; //с пробелом
					break;
				case 2:
					part2 = part2 + " " + this->allnodes[index].name; //а здесь в любом случае с пробелом, потому что идЄт вслед за первой строкой, котора€ заканчиваетс€ без пробела
					break;
			}
		}
		out << part1 << part2 << "\n"; //выводим общую строку в файл
	}
	out.close(); //«акрываем файл
	cout << "”—ѕ≈’: ‘айл успешно сохранЄн по адресу \"" << savepath << "\"\n\n"; //сообщаем
	return; //выходим
}

int main()
{
	setlocale(LC_ALL, "Rus"); //корректное отображение  ириллицы
	Graph graph; //создаЄм объект класса граф
	if (!graph.CellReading()) //если не удаЄтс€ успешно сосчитать всЄ из файла и разнести смежные узлы
	{
		cout << "¬Ќ≈ѕЋјЌќ¬ќ≈ «ј¬≈–Ў≈Ќ»≈ ѕ–ќ√–јћћџ\n"; //то сообщаем об этом
		system("PAUSE");							 //делаем пафосную паузу в ожидании нажати€
		return 0;									//и завершаем работу программы
	}
	/*Ќј„јЋќ: ¬озможность проверки смежных узлов (оставить дл€ дебагинга)*/
	char ch; //переменна€, в которой будет хранитьс€ символы, нажатые пользователем с клавиатуры
	cout << "\n¬ќѕ–ќ—: ¬ключить проверку смежных узлов? (Y/N) "; //возникнет ошибка, если ввести символ на кириллице!
	do {
		ch = _getch(); //считываем и запоминаем (без вывода на экран символа)
		if (islower(ch)) ch = toupper(ch); //если прописна€, то делаем строчной
	} while ((ch != 'Y') && (ch != 'N')); //пока не будет нажата Y или N
	cout << ch << "\n\n"; //выводим нажатый сивол-выбор на экран и чуть опускаемс€
	if (ch == 'Y') //если хот€т проверки
	{
		string s = ""; //вспомогательна€ переменна€
		for (int i = 0; i < graph.cn; i++) //дл€ всех узлов
		{
			cout << " оличество соседей у узла с именем \"" << graph.allnodes[i].name << "\": " << graph.allnodes[i].neighbors.size() << "; "; //.size() - возвращает размер множества
			cout << "—оседи: ";
			for (uint const& j : graph.allnodes[i].neighbors) //выводим содержимое множества на экран
			{
				cout << graph.allnodes[j].name << " ";
			}
			cout << "\n";
		}
	}
	cout << "\n";
	/* ќЌ≈÷: ¬озможность проверки смежных узлов (оставить дл€ дебагинга)*/
	if (graph.IsItBipartite()) graph.SaveOutputFile(); //если граф двудольный, то запускаем сохранение выходного файла
	system("PAUSE");
	return 0;
}