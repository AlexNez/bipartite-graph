#include "stdafx.h"
#include "class.h"

bool Graph::CellReading() //метод класса для считывания данных из файла и создания смежных связей между соседними узлами
{
	string s1, s2; //буфер-строки для считывания имён узлов из файла
	ifstream in("C:\\graph.txt");
	uint i = 0; //вспомогательный челочисленный счётчик
	uint nodeindex = 0; //номер текущего индекса в массиве allnodes графа (а также счётчик количества узлов)
	uint help; //вспомогательная переменная
	/*НАЧАЛО: выясняем количество строк/ячеек*/
	while (!in.eof()) //пока не достигнут конец файла
	{
		i++; //наращиваем количество строк
		getline(in, s1); //считываем следующую строку из файла
	}
	in.close(); //закрываем файл
	/*КОНЕЦ: выясняем количество строк=ячеек*/
	in.open("C:\\graph.txt"); //открываем заново, чтобы сместить указатель в начало файла
	cout << "Количество ячеек в объявленной сетке: " << i << "\n";
	this->cc = i; //запоминаем количество ячеек
	this->cn = 4 * i; //временно устанавливаем максимальное количество узлов
	this->cells = new Cell[i]; //создаём массив ячеек в текущем объекте
	Node *tempnodes; //временный массив узлов
	tempnodes = new Node[this->cn]; //устанавливаем максимальный размер
	uint j = 0; // счётчик для нынешней ячейки
	while (!in.eof())
	{
		getline(in, s1); // Считываем строчку в переменную s1
		uint k = 0; // счётчик узлов внутри ячейки
		s2 = "";
		for (i = 0; s1[i] != *""; i++) //пока не будет достигнут конец строки
		{
			if (i > sizeof(s1)) //если номер текущего символа стал больше, чем размер unsigned int
			{
				cout << "ОШИБКА: слишком длинное название ячейки.\nУвеличьте размер буфера";
				in.close(); //Закрываем файл
				return false; //выход из подпрограммы
			}
			if (s1[i] != *" ") //если текущий символ - не пробел
			{
				s2 = s2 + s1[i]; //то дополняем им s2
			}
			else
			{
				help = 0; //на каждом шаге обнуляем вспомогательную переменную, иначе всё сломается
				for (uint l = 0; l < this->cn; l++) //для всех узлов
					if (tempnodes[l].name == s2) //ищем узел с таким же именем
					{
						help = l; //если нашли, то запоминаем его индекс
						break;
					};
				if (help != 0) this->cells[j].nodes[k] = help; //и записываем его в качестве индекса для текущего узла
				else //а если не нашли
				{
					tempnodes[nodeindex].name = s2; //то создаём новый узел во временном массиве с текущим именем
					this->cells[j].nodes[k] = nodeindex; //и записываем его индекс
					nodeindex++; //увеличивая при этом количество неповторяющихся узлов на 1
				}
				k++; //ещё один узел в ячейке сохранён
				s2 = ""; //обнуляем строку
			}
		}
		/*НАЧАЛО: Так как мы дошли до конца строки, которая не выделяется разделителем-пробелом,
		то 4-ому узлу присваиваем имя вне цикла*/
		//этот момент аналогичен таким же на предыдущих шагах
		help = 0;
		for (uint l = 0; l < this->cn; l++)
			if (tempnodes[l].name == s2)
			{
				help = l;
				break;
			};
		if (help != 0) this->cells[j].nodes[k] = help;
		else
		{
			tempnodes[nodeindex].name = s2;
			this->cells[j].nodes[k] = nodeindex;
			nodeindex++;
		}
		j++;
		/*КОНЕЦ: Так как мы дошли до конца строки, которая не выделяется разделителем-пробелом,
		то 4-ому узлу присваиваем имя вне цикла*/
	}
	in.close(); //Закрываем файл
	this->allnodes = new Node[nodeindex]; //создаём общий массив узлов в объекте по узнанному количеству узлов
	for (i = 0; i < nodeindex; i++) //для всех узлов
		this->allnodes[i].name = tempnodes[i].name; //копируем их имена в основной массив объекта
	delete[] tempnodes; //удаляем временный массив
	this->cn = nodeindex; //корректируем количество узлов
	cout << "Количество узлов в объявленной сетке: " << nodeindex << "\n"; //сообщаем великую новость

	/*НАЧАЛО: Проверка правильности занесения данных из файла в классовую структуру (оставить для дебагинга)*/
	char ch;
	cout << "\nВОПРОС: Вывести на экран содержимое ячеек? (Y/N) "; //возникнет ошибка, если ввести символ на кириллице
	do {
		ch = _getch();
		if (islower(ch)) ch = toupper(ch);
	} while ((ch != 'Y') && (ch != 'N'));
	cout << ch << "\n\n";
	if (ch == 'Y')
	{
		for (j = 0; j < this->cc; j++)
		{
			cout << "Ячейка №" << j + 1 << ": ";
			for (int k = 0; k <= 3; k++) cout << this->allnodes[this->cells[j].nodes[k]].name << " ";
			cout << "\n";
		}
		cout << "\n";
	}
	/*КОНЕЦ: Проверка правильности занесения данных из файла в классовую структуру (оставить для дебагинга)*/

	/*ЗАПОЛНЕНИЕ ДАННЫМИ О СМЕЖНЫХ УЗЛАХ*/
	for (i = 0; i < this->cc; i++) //обходим все ячейки
	{
		uint index; //вспомогательная переменная
		Cell c; //вспомогательный объяект-ячейка
		for (uint k = 0; k < 4; k++) //обходим все 4 узла ячейки
			/*соседи определяются взависимости от положения узла (первый - нижний левый, направление - против часовой стрелки)*/
			switch (k)
			{
				case 0: //если первый узел
					c = this->cells[i]; //сокращаем название
					index = c.nodes[k]; //вытаскиваем индекс узла для массива allnodes в графе
					this->allnodes[c.nodes[3]].neighbors.insert(index); //добавляем первый узел в множство соседей
					this->allnodes[c.nodes[1]].neighbors.insert(index); //второго и последнего порядкового узлов
					break;
				case 1: //если второй узел
					c = this->cells[i];
					index = c.nodes[k];
					this->allnodes[c.nodes[0]].neighbors.insert(index);
					this->allnodes[c.nodes[2]].neighbors.insert(index); //первого и третьего
					break;
				case 2: //если третий узел
					c = this->cells[i];
					index = c.nodes[k];
					this->allnodes[c.nodes[1]].neighbors.insert(index);
					this->allnodes[c.nodes[3]].neighbors.insert(index); //второго и последнего
					break;
				case 3: //если последний узел
					c = this->cells[i];
					index = c.nodes[k];
					this->allnodes[c.nodes[2]].neighbors.insert(index);
					this->allnodes[c.nodes[0]].neighbors.insert(index); //третьего и первого
					break;
			}
	}
	cout << "УСПЕХ: Файл считан корректно!\n"; //вывод на экран
	return true; //успешно завершаем программу
}

bool Graph::CheckAndMark(uint index, int c) //рекурентная функция обхода в глубину
{
	this->allnodes[index].flag = c; //присваиваем переданный флаг узлу с переданным индексом
	for (uint i = 0; i < this->cn; i++) //перебираем все индексы узлов
		if (this->allnodes[index].neighbors.count(i)) //если встречаем его в множестве "соседей" узла переданного индекса
			switch (this->allnodes[i].flag) //то смотрим на флаг "соседа"
			{
				case 0: //если не установлен
					if (c == 1) //то в зависимости от переданного флага
					{
						if (!this->CheckAndMark(i, 2)) //рекурентно вызываем этот же метод, где
						{							  //где ему будет присвоен передаваемый флаг (отличный от нынешнего)
							return false;			 //а также просмотрены все его "соседи"
						}
					}
					else
					{
						if (!this->CheckAndMark(i, 1))
						{
							return false;
						}
					}
					break;
				case 1: //если в узле уже установлен флаг, то проверяем
					if (c == 1) return false; //его на равенство нынешнему - если равен, то граф недвудольный
					break;
				case 2:
					if (c == 2) return false;
					break;
			}
	return true; //если дошло до сюда, то значит с этим узлом всё ок
}

bool Graph::IsItBipartite() //метод, возвращающий ответ на вопрос
{
	bool b = this->CheckAndMark(this->cells[0].nodes[0], 1); //запоминаем ответ на вопрос (передаём в метод самый первый узели говорим, что нужно метить его в первую долю)
	if (b) cout << "ОТВЕТ: ГРАФ ЯВЛЯЕТСЯ ДВУДОЛЬНЫМ\n\n";
	else cout << "ОТВЕТ: ГРАФ НЕ ЯВЛЯЕТСЯ ДВУДОЛЬНЫМ\n\n";
	return b; //возвращаем логический ответ
}

void Graph::SaveOutputFile() //метод сохранение выходного файла
{
	string savepath = "C:\\output.txt"; //указываем путь для сохранения
	ofstream out(savepath); // Открываем файл для записи
	string part1,part2; // вспомогающие строки первой и второй долей
	uint index; //вспомогательная переменная
	for (int i = 0; i < this->cc; i++) //для все ячеек
	{
		part1 = part2 = ""; //обнуляем строки
		for (int j = 0; j < 4; j++) //и всех узлов в каждой из ячейки
		{
			index = this->cells[i].nodes[j]; //считываем индекс узла в общем массиве
			switch (this->allnodes[index].flag) //смотрим на его флаг
			{
				case 1: //если "покрашен" в первую долю
					if (part1 == "") part1 = this->allnodes[index].name; //то заносим имя узла в строку без пробела
					else part1 = part1 + " " + this->allnodes[index].name; //с пробелом
					break;
				case 2:
					part2 = part2 + " " + this->allnodes[index].name; //а здесь в любом случае с пробелом, потому что идёт вслед за первой строкой, которая заканчивается без пробела
					break;
			}
		}
		out << part1 << part2 << "\n"; //выводим общую строку в файл
	}
	out.close(); //Закрываем файл
	cout << "УСПЕХ: Файл успешно сохранён по адресу \"" << savepath << "\"\n\n"; //сообщаем
	return; //выходим
}

int main()
{
	setlocale(LC_ALL, "Rus"); //корректное отображение Кириллицы
	Graph graph; //создаём объект класса граф
	if (!graph.CellReading()) //если не удаётся успешно сосчитать всё из файла и разнести смежные узлы
	{
		cout << "ВНЕПЛАНОВОЕ ЗАВЕРШЕНИЕ ПРОГРАММЫ\n"; //то сообщаем об этом
		system("PAUSE");							 //делаем пафосную паузу в ожидании нажатия
		return 0;									//и завершаем работу программы
	}
	/*НАЧАЛО: Возможность проверки смежных узлов (оставить для дебагинга)*/
	char ch; //переменная, в которой будет храниться символы, нажатые пользователем с клавиатуры
	cout << "\nВОПРОС: Включить проверку смежных узлов? (Y/N) "; //возникнет ошибка, если ввести символ на кириллице!
	do {
		ch = _getch(); //считываем и запоминаем (без вывода на экран символа)
		if (islower(ch)) ch = toupper(ch); //если прописная, то делаем строчной
	} while ((ch != 'Y') && (ch != 'N')); //пока не будет нажата Y или N
	cout << ch << "\n\n"; //выводим нажатый сивол-выбор на экран и чуть опускаемся
	if (ch == 'Y') //если хотят проверки
	{
		string s = ""; //вспомогательная переменная
		for (int i = 0; i < graph.cn; i++) //для всех узлов
		{
			cout << "Количество соседей у узла с именем \"" << graph.allnodes[i].name << "\": " << graph.allnodes[i].neighbors.size() << "; "; //.size() - возвращает размер множества
			cout << "Соседи: ";
			for (uint const& j : graph.allnodes[i].neighbors) //выводим содержимое множества на экран
			{
				cout << graph.allnodes[j].name << " ";
			}
			cout << "\n";
		}
	}
	cout << "\n";
	/*КОНЕЦ: Возможность проверки смежных узлов (оставить для дебагинга)*/
	if (graph.IsItBipartite()) graph.SaveOutputFile(); //если граф двудольный, то запускаем сохранение выходного файла
	system("PAUSE");
	return 0;
}